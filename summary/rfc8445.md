> [Read original](../md/rfc8445.md)

---

#  Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal

## 1. Introduction

- NAT越えの方法は今までもいろいろあったけど、その結論的ポジションがICE
- STUNを使ってOffer/Answer方式でIPとポートを交換する
- TURNを使うこともある

## 2. Overview of ICE

- ICEは2拠点をつなぐもの
- それぞれなんらかのアドレスを持ってるはず（NAT内での・STUN経由でNAT外から見てなど）
- それらのアドレスのペアから、つながる組み合わせを見つけるための仕組み

### 2.1. Gathering Candidates

- IPアドレスとポートのセットをトランスポートアドレスと呼ぶ
- これを収集する用途がある
- host/srflx/relayの3種がある（STUNを使うとsrflxが、TURNならsrflxとrelayがわかる）

### 2.2. Connectivity Checks

- 候補が揃ったらそれを優先度順に並び替えて(check list)送りあう
- 両方にcheck listが揃ったら、STUNをつかってそれぞれ疎通確認をする
  - STUNで使うポートは、実際にRTPやらが流れるポートになるのでご注意
  - NATの都合で、リストにないアドレスから返ってくることもある = prflxとしてcheck listに足す
  - 両方に揃うのを待たず、片方が送ってきたらそれに対して返信してもいい（triggered check)
- 疎通できたものはvalid listとして管理

### 2.3. Nominating Candidate Pairs and Concluding ICE

- ICEでやり取りする2拠点は、controllingかcontrolledかどっちかの役割になる
- controlling側がvalid listに沿ってSTUNリクエストを送り、controlled側も同じことをする
- これが終わると、最終的なペアが決まったことを表すSTUNリクエストが送られる
  - 以降はこのペア間でのみ通信が成される
  - 優先度順になってるので、1つ決まればほかはもう止めていい

### 2.4. ICE Restart

- 今までのやり取りが終わった後も、リスタートができる

### 2.5. Lite Implementations

- グローバルなIPを固定で持ってるなどの場合は、諸々の手順をスキップできる
- そんなICEの実装のことを、Liteと呼ぶ

## 3. ICE Usage

- ここで書いてる以外にも、ICEの使い方は定義されてる
- SIPとか
- RTSPとか

## 4. Terminology

- いつもの
- その他の用語集もココ

## 5. ICE Candidate Gathering and Exchange

- ICEの手続きとして、集めた経路は交換される
- ただその交換方法はこの文書では規定してない

### 5.1. Full Implementation

- 本文なし

#### 5.1.1. Gathering Candidates

- candidateの構成要素3つ
  - トランスポートアドレス（IP, port） / type(host, srflx, prflx, relay) / base
- UIきっかけでcandidateを集め始める（はじめる側）
- はじめる側からcandidateを受け取ったらすぐ集め始める（こたえる側）

##### 5.1.1.1. Host Candidates

- hostから取得できるcandidate
  - loopbackアドレスは含まないなど例外がいくつかある
- UDPポートを実際にバインドすることで候補に入れる
  - コンポーネント（RTPとRTCP（これは同一ポートで捌かれることもある）、SCTP）ごとに
  - 最近のWebRTCはデフォルトでRTP/RTCPはmultiplexされててコンポーネントは1つ
- host candidateのbaseは自分自身になる

##### 5.1.1.2. Server-Reflexive and Relayed Candidates

- STUN/TURN利用は必須ではないし設定で選べるように
  - 使ったら、srflx/relayなcandidateが取れる
  - STUNもTURNも複数のサーバーを指定できてもいいが、結果は変わらない
- STUN/TURNへの問い合わせはタイマー（Ta）に従って行う
  - 再送とかも
- baseはそれぞれ
  - srflx: STUN/TURNにリクエストを送ったhostと同じ
  - relay: relay candidate自身

##### 5.1.1.3. Computing Foundations

- candidateにはfoundationというグルーピング（IDみたいなもの）がある
- 以下すべてに該当するcandidateは、同じfoundationに属するとしてまとめて扱われる
  - typeが同じ
  - IPが同じ（ポートは違う）
  - srflx, prflxでIPが同じ
  - protocolが同じ

##### 5.1.1.4. Keeping Candidates Alive

- srflx, prflxなcandidateは、ICEの手続きが終わるまでkeep-aliveする必要がある
  - 詳細はSection 8.3にて
  - 同じようにSTUNならBindingリクエストを送信することでOK
  - TURNならRefreshでsrflxもまとめて更新
- hostなcandidateは不変だと思うが、いちおうチェックしておくとよい

#### 5.1.2. Prioritizing Candidates

- candidateに優先度をつける
  - candidateごとにユニークな値
  - 値の計算式はSection 5.1.2.1にて
- 優先度が高い順に疎通確認される

##### 5.1.2.1. Recommended Formula

- 優先度には推奨される計算式がある
  - type pref / local pref / componentID から算出される
- type: `0~126`
  - typeごとに異なる値
  - prflx > srflxになるように
- local: `0-65535`
  - IPのfamilyが1つなら`65535`で固定
  - IPv4/IPv6両対応なら、RFC8421を見てね
- componentID: `1~256`

##### 5.1.2.2. Guidelines for Choosing Type and Local Preferences

- おすすめのpref値
- type pref
  - host: `126`
  - prflx: `110`
  - srflx: `100`
  - relay: `0`

#### 5.1.3. Eliminating Redundant Candidates

- 冗長なcandidateの削除
- トランスポートアドレスが同じでbaseが同じなら削除
- 優先度が低い方を削除

### 5.2. Lite Implementation Procedures

- ICE-Liteの場合
- `host`のcandidateだけを扱う
  - familyごとに0か1つの候補だけ
- componentIDが決まってる
  - RTP: `1`
  - RTCP: `2`
  - RTP/RTCP: `1`
- foundationも決まる
  - IPアドレスごとに異なる値
  - 単にインクリメントした値でいい（最初は`1`、次は`2`とか）
- priorityも異なる値
  - 5.1.2.1. に従う
- IPv4 / IPv6のデュアルスタックなら、どっちをデフォルトにするか決めていい
  - なるべく時勢に適したやつを

### 5.3. Exchanging Candidate Information

- candidateっていってるものに含まれるべき情報について
- candidateの情報を送る = データが流れる準備ができている表明になる
  - すぐにSTUNやデータが流れてきてもいいようにせよ

### 5.4. ICE Mismatch

- ALG(ApplicationLayerGateway)みたいな中継機が挟まる場合
  - SDP内のIPアドレスを書き換えたりする
- こういう減少をICEミスマッチという
- 検知できたらお互いに知らせてあげる

## 6. ICE Candidate Processing

### 6.1. Procedures for Full Implementation

#### 6.1.1. Determining Role

#### 6.1.2. Forming the Checklists

##### 6.1.2.1. Checklist State

##### 6.1.2.2. Forming Candidate Pairs

##### 6.1.2.3. Computing Pair Priority and Ordering Pairs

##### 6.1.2.4. Pruning the Pairs

##### 6.1.2.5. Removing Lower-Priority Pairs

##### 6.1.2.6. Computing Candidate Pair States

#### 6.1.3. ICE State

#### 6.1.4. Scheduling Checks

##### 6.1.4.1. Triggered-Check Queue

##### 6.1.4.2. Performing Connectivity Checks

### 6.2. Lite Implementation Procedures

## 7. Performing Connectivity Checks

### 7.1. STUN Extensions

#### 7.1.1. PRIORITY

#### 7.1.2. USE-CANDIDATE

#### 7.1.3. ICE-CONTROLLED and ICE-CONTROLLING

### 7.2. STUN Client Procedures

#### 7.2.1. Creating Permissions for Relayed Candidates

#### 7.2.2. Forming Credentials

#### 7.2.3. Diffserv Treatment

#### 7.2.4. Sending the Request

#### 7.2.5. Processing the Response

##### 7.2.5.1. Role Conflict

##### 7.2.5.2. Failure

###### 7.2.5.2.1. Non-Symmetric Transport Addresses

###### 7.2.5.2.2. ICMP Error

###### 7.2.5.2.3. Timeout

###### 7.2.5.2.4. Unrecoverable STUN Response

##### 7.2.5.3. Success

###### 7.2.5.3.1. Discovering Peer-Reflexive Candidates

###### 7.2.5.3.2. Constructing a Valid Pair

###### 7.2.5.3.3. Updating Candidate Pair States

###### 7.2.5.3.4. Updating the Nominated Flag

##### 7.2.5.4. Checklist State Updates

### 7.3. STUN Server Procedures

#### 7.3.1. Additional Procedures for Full Implementations

##### 7.3.1.1. Detecting and Repairing Role Conflicts

##### 7.3.1.2. Computing Mapped Addresses

##### 7.3.1.3. Learning Peer-Reflexive Candidates

##### 7.3.1.4. Triggered Checks

##### 7.3.1.5. Updating the Nominated Flag

#### 7.3.2. Additional Procedures for Lite Implementations

## 8. Concluding ICE Processing

### 8.1. Procedures for Full Implementations

#### 8.1.1. Nominating Pairs

#### 8.1.2. Updating Checklist and ICE States

### 8.2. Procedures for Lite Implementations

### 8.3. Freeing Candidates

#### 8.3.1. Full Implementation Procedures

#### 8.3.2. Lite Implementation Procedures

## 9. ICE Restarts

## 10. ICE Option

## 11. Keepalives

## 12. Data Handling

### 12.1. Sending Data

#### 12.1.1. Procedures for Lite Implementations

### 12.2. Receiving Data

## 13. Extensibility Considerations

## 14. Setting Ta and RTO

### 14.1. General

### 14.2. Ta

### 14.3. RTO

## 15. Examples

### 15.1. Example with IPv4 Addresses

### 15.2. Example with IPv6 Addresses

## 16. STUN Extensions

### 16.1. Attributes

### 16.2. New Error-Response Codes

## 17. Operational Considerations

### 17.1. NAT and Firewall Types

### 17.2. Bandwidth Requirements

#### 17.2.1. STUN and TURN Server-Capacity Planning

#### 17.2.2. Gathering and Connectivity Checks

#### 17.2.3. Keepalives

### 17.3. ICE and ICE-Lite

### 17.4. Troubleshooting and Performance Management

### 17.5. Endpoint Configuration

## 18. IAB Considerations

### 18.1. Problem Definition

### 18.2. Exit Strategy

### 18.3. Brittleness Introduced by ICE

### 18.4. Requirements for a Long-Term Solution

### 18.5. Issues with Existing NAPT Boxes

## 19. Security Considerations

### 19.1. IP Address Privacy

### 19.2. Attacks on Connectivity Checks

### 19.3. Attacks on Server-Reflexive Address Gathering

### 19.4. Attacks on Relayed Candidate Gathering

### 19.5. Insider Attacks

#### 19.5.1. STUN Amplification Attack

## 20. IANA Considerations

### 20.1. STUN Attributes

### 20.2. STUN Error Responses

### 20.3. ICE Options

## Appendix A. Lite and Full Implementations

## Appendix B. Design Motivations

### B.1. Pacing of STUN Transactions

### B.2. Candidates with Multiple Bases

### B.3. Purpose of the Related-Address and Related-Port Attributes

### B.4. Importance of the STUN Username

### B.5. The Candidate Pair Priority Formula

### B.6. Why Are Keepalives Needed?

### B.7. Why Prefer Peer-Reflexive Candidates?

### B.8. Why Are Binding Indications Used for Keepalives?

### B.9. Selecting Candidate Type Preference

## Appendix C. Connectivity-Check Bandwidth
